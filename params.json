{"name":"Configor","tagline":"Golang Configuration tool that support YAML, JSON, Shell Environment","body":"# Configor\r\n\r\nGolang Configuration tool that support YAML, JSON, Shell Environment\r\n\r\n# Usage\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"github.com/jinzhu/configor\"\r\n)\r\n\r\nvar Config = struct {\r\n\tAPPName string `default:\"app name\"`\r\n\r\n\tDB struct {\r\n\t\tName     string\r\n\t\tUser     string `default:\"root\"`\r\n\t\tPassword string `required:\"true\" env:\"DBPassword\"`\r\n\t\tPort     uint   `default:\"3306\"`\r\n\t}\r\n\r\n\tContacts []struct {\r\n\t\tName  string\r\n\t\tEmail string `required:\"true\"`\r\n\t}\r\n}{}\r\n\r\nfunc main() {\r\n\tconfigor.Load(&Config, \"config.yml\")\r\n\tfmt.Printf(\"config: %#v\", Config)\r\n}\r\n```\r\n\r\nWith configuration file *config.yml*:\r\n\r\n```yaml\r\nAPPName: test\r\n\r\nDB:\r\n    Name:     test\r\n    User:     test\r\n    Password: test\r\n    Port:     1234\r\n\r\nContacts:\r\n- Name: i test\r\n  Email: test@test.com\r\n```\r\n\r\n# Advanced Usage\r\n\r\n* Load mutiple configurations\r\n\r\n```go\r\n// Earlier configurations have higher priority\r\nconfigor.Load(&Config, \"application.yml\", \"database.json\")\r\n```\r\n\r\n* Different configuration for each environment\r\n\r\nUse `CONFIGOR_ENV` to set the environment.\r\n\r\nIf `CONFIGOR_ENV` not set, when running tests with `go test`, the ENV will be `test`, otherwise, it will be `development`\r\n\r\n```go\r\n// config.go\r\nconfigor.Load(&Config, \"config.json\")\r\n\r\n$ go run config.go\r\n// Will load `config.json`, `config.development.json` if it is exist\r\n// And `config.development.json` will overwrite `config.json`'s configuration\r\n// You could use this to share same configuration across different environments\r\n\r\n$ CONFIGOR_ENV=production go run config.go\r\n// Will load `config.json`, `config.production.json` if it is exist\r\n// And `config.production.json` will overwrite `config.json`'s configuration\r\n\r\n$ go test\r\n// Will load `config.json`, `config.test.json` if it is exist\r\n// And `config.test.json` will overwrite `config.json`'s configuration\r\n\r\n$ CONFIGOR_ENV=production go test\r\n// Will load `config.json`, `config.production.json` if it is exist\r\n// And `config.production.json` will overwrite `config.json`'s configuration\r\n```\r\n\r\n* Example Configuration\r\n\r\n```go\r\n// config.go\r\nconfigor.Load(&Config, \"config.yml\")\r\n\r\n$ go run config.go\r\n// Will load `config.example.yml` automatically if `config.yml` not found and print warning message\r\n```\r\n\r\n* Read From Shell Environment\r\n\r\n```go\r\n$ CONFIGOR_APPNAME=\"hello world\" CONFIGOR_DB_NAME=\"hello world\" go run config.go\r\n// Will use shell environment's value if found with upcase of prefix (by default is CONFIGOR) + field name as key\r\n// You could overwrite the prefix with environment CONFIGOR_ENV_PREFIX, for example:\r\n$ CONFIGOR_ENV_PREFIX=\"WEB\" WEB_APPNAME=\"hello world\" WEB_DB_NAME=\"hello world\" go run config.go\r\n```\r\n\r\n* With flags\r\n\r\n```go\r\nfunc main() {\r\n\tconfig := flag.String(\"file\", \"config.yml\", \"configuration file\")\r\n\tflag.StringVar(&Config.APPName, \"name\", \"\", \"app name\")\r\n\tflag.StringVar(&Config.DB.Name, \"db-name\", \"\", \"database name\")\r\n\tflag.StringVar(&Config.DB.User, \"db-user\", \"root\", \"database user\")\r\n\tflag.Parse()\r\n\r\n\tos.Setenv(\"CONFIGOR_ENV_PREFIX\", \"-\")\r\n\tconfigor.Load(&Config, *config)\r\n\t// configor.Load(&Config) // only load configurations from shell env & flag\r\n}\r\n```\r\n\r\n# Author\r\n\r\n**jinzhu**\r\n\r\n* <http://github.com/jinzhu>\r\n* <wosmvp@gmail.com>\r\n* <http://twitter.com/zhangjinzhu>\r\n\r\n## License\r\n\r\nReleased under the MIT License\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}